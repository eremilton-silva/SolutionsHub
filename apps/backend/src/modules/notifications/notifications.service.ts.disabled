import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import { Notification, NotificationStatus, NotificationType, NotificationPriority } from './entities/notification.entity';
import { NotificationTemplate } from './entities/notification-template.entity';
import { CreateNotificationDto } from './dto/create-notification.dto';
import { UpdateNotificationDto } from './dto/update-notification.dto';
import { CreateBulkNotificationDto } from './dto/create-bulk-notification.dto';
import { CreateTemplateNotificationDto } from './dto/create-template-notification.dto';
import { NotificationStatsDto } from './dto/notification-stats.dto';

@Injectable()
export class NotificationsService {
  private readonly logger = new Logger(NotificationsService.name);

  constructor(
    @InjectRepository(Notification)
    private notificationRepository: Repository<Notification>,
    @InjectRepository(NotificationTemplate)
    private templateRepository: Repository<NotificationTemplate>,
  ) {}

  async create(createNotificationDto: CreateNotificationDto): Promise<Notification> {
    const notificationData = {
      ...createNotificationDto,
      scheduledAt: createNotificationDto.scheduledAt ? new Date(createNotificationDto.scheduledAt) : new Date(),
      expiresAt: createNotificationDto.expiresAt ? new Date(createNotificationDto.expiresAt) : undefined,
    };

    const notification = this.notificationRepository.create(notificationData);
    const savedNotification = await this.notificationRepository.save(notification);

    // Se for para envio imediato, processar
    if (!createNotificationDto.scheduledAt || new Date(createNotificationDto.scheduledAt) <= new Date()) {
      this.processNotification(savedNotification.id);
    }

    return savedNotification;
  }

  async createBulk(createBulkDto: CreateBulkNotificationDto): Promise<Notification[]> {
    const notifications: Notification[] = [];
    
    for (const userId of createBulkDto.userIds) {
      const notificationData = {
        title: createBulkDto.title,
        message: createBulkDto.message,
        type: createBulkDto.type,
        priority: createBulkDto.priority,
        category: createBulkDto.category,
        data: createBulkDto.data,
        metadata: createBulkDto.metadata,
        userId,
        scheduledAt: createBulkDto.scheduledAt ? new Date(createBulkDto.scheduledAt) : new Date(),
        expiresAt: createBulkDto.expiresAt ? new Date(createBulkDto.expiresAt) : undefined,
      };

      const notification = this.notificationRepository.create(notificationData);
      notifications.push(notification);
    }

    const savedNotifications = await this.notificationRepository.save(notifications);

    // Processar notificações imediatas
    for (const notification of savedNotifications) {
      if (!createBulkDto.scheduledAt || new Date(createBulkDto.scheduledAt) <= new Date()) {
        this.processNotification(notification.id);
      }
    }

    return savedNotifications;
  }

  async findAll(userId?: string, page = 1, limit = 20): Promise<{ notifications: Notification[]; total: number }> {
    const query = this.notificationRepository.createQueryBuilder('notification');

    if (userId) {
      query.where('notification.userId = :userId', { userId });
    }

    query
      .orderBy('notification.createdAt', 'DESC')
      .skip((page - 1) * limit)
      .take(limit);

    const [notifications, total] = await query.getManyAndCount();

    return { notifications, total };
  }

  async findOne(id: string): Promise<Notification> {
    const notification = await this.notificationRepository.findOne({
      where: { id },
    });

    if (!notification) {
      throw new NotFoundException(`Notificação com ID ${id} não encontrada`);
    }

    return notification;
  }

  async update(id: string, updateNotificationDto: UpdateNotificationDto): Promise<Notification> {
    const notification = await this.findOne(id);

    const updatedData = {
      ...updateNotificationDto,
      scheduledAt: updateNotificationDto.scheduledAt ? new Date(updateNotificationDto.scheduledAt) : notification.scheduledAt,
      expiresAt: updateNotificationDto.expiresAt ? new Date(updateNotificationDto.expiresAt) : notification.expiresAt,
    };

    Object.assign(notification, updatedData);
    return this.notificationRepository.save(notification);
  }

  async remove(id: string): Promise<void> {
    const notification = await this.findOne(id);
    await this.notificationRepository.remove(notification);
  }

  async markAsRead(id: string): Promise<Notification> {
    const notification = await this.findOne(id);
    notification.status = NotificationStatus.READ;
    notification.readAt = new Date();
    return this.notificationRepository.save(notification);
  }

  async markAsDelivered(id: string): Promise<Notification> {
    const notification = await this.findOne(id);
    notification.status = NotificationStatus.DELIVERED;
    notification.deliveredAt = new Date();
    return this.notificationRepository.save(notification);
  }

  async getStats(userId?: string): Promise<NotificationStatsDto> {
    const query = this.notificationRepository.createQueryBuilder('notification');

    if (userId) {
      query.where('notification.userId = :userId', { userId });
    }

    const total = await query.getCount();
    const sent = await query.clone().andWhere('notification.status = :status', { status: NotificationStatus.SENT }).getCount();
    const delivered = await query.clone().andWhere('notification.status = :status', { status: NotificationStatus.DELIVERED }).getCount();
    const read = await query.clone().andWhere('notification.status = :status', { status: NotificationStatus.READ }).getCount();
    const failed = await query.clone().andWhere('notification.status = :status', { status: NotificationStatus.FAILED }).getCount();

    // Estatísticas por tipo
    const byType = {};
    const types = Object.values(NotificationType);
    for (const type of types) {
      byType[type] = await query.clone().andWhere('notification.type = :type', { type }).getCount();
    }

    // Estatísticas por prioridade
    const byPriority = {};
    const priorities = Object.values(NotificationPriority);
    for (const priority of priorities) {
      byPriority[priority] = await query.clone().andWhere('notification.priority = :priority', { priority }).getCount();
    }

    return {
      total,
      sent,
      delivered,
      read,
      failed,
      pending: total - sent - delivered - read - failed,
      byType,
      byPriority,
      deliveryRate: total > 0 ? (delivered / total) * 100 : 0,
      readRate: total > 0 ? (read / total) * 100 : 0,
    };
  }

  private async processNotification(notificationId: string): Promise<void> {
    try {
      const notification = await this.findOne(notificationId);
      
      // Simular processamento da notificação
      this.logger.log(`Processando notificação ${notificationId} do tipo ${notification.type}`);
      
      // Aqui seria implementada a lógica específica para cada tipo de notificação
      switch (notification.type) {
        case NotificationType.EMAIL:
          await this.sendEmail(notification);
          break;
        case NotificationType.SMS:
          await this.sendSms(notification);
          break;
        case NotificationType.WHATSAPP:
          await this.sendWhatsApp(notification);
          break;
        case NotificationType.PUSH:
          await this.sendPush(notification);
          break;
        case NotificationType.IN_APP:
          await this.sendInApp(notification);
          break;
      }

      // Marcar como enviada
      notification.status = NotificationStatus.SENT;
      notification.sentAt = new Date();
      await this.notificationRepository.save(notification);

    } catch (error) {
      this.logger.error(`Erro ao processar notificação ${notificationId}:`, error);
      
      // Marcar como falha
      const notification = await this.findOne(notificationId);
      notification.status = NotificationStatus.FAILED;
      notification.errorMessage = error.message;
      await this.notificationRepository.save(notification);
    }
  }

  private async sendEmail(notification: Notification): Promise<void> {
    this.logger.log(`Enviando email para ${notification.userId}: ${notification.title}`);
    // Implementar integração com SendGrid/Amazon SES
  }

  private async sendSms(notification: Notification): Promise<void> {
    this.logger.log(`Enviando SMS para ${notification.userId}: ${notification.title}`);
    // Implementar integração com provedor de SMS
  }

  private async sendWhatsApp(notification: Notification): Promise<void> {
    this.logger.log(`Enviando WhatsApp para ${notification.userId}: ${notification.title}`);
    // Implementar integração com WhatsApp Business API
  }

  private async sendPush(notification: Notification): Promise<void> {
    this.logger.log(`Enviando push notification para ${notification.userId}: ${notification.title}`);
    // Implementar integração com Firebase/OneSignal
  }

  private async sendInApp(notification: Notification): Promise<void> {
    this.logger.log(`Criando notificação in-app para ${notification.userId}: ${notification.title}`);
    // Notificação in-app já está salva no banco, apenas atualizar status
  }

  @Cron(CronExpression.EVERY_MINUTE)
  async processScheduledNotifications(): Promise<void> {
    const now = new Date();
    
    const scheduledNotifications = await this.notificationRepository.find({
      where: {
        status: NotificationStatus.PENDING,
        scheduledAt: Between(new Date(now.getTime() - 60000), now), // Últimos 60 segundos
      },
    });

    for (const notification of scheduledNotifications) {
      await this.processNotification(notification.id);
    }
  }

  @Cron(CronExpression.EVERY_HOUR)
  async retryFailedNotifications(): Promise<void> {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    
    const failedNotifications = await this.notificationRepository.find({
      where: {
        status: NotificationStatus.FAILED,
        retryCount: 0, // Apenas primeira tentativa de retry
        createdAt: Between(oneHourAgo, new Date()),
      },
    });

    for (const notification of failedNotifications) {
      notification.retryCount = (notification.retryCount || 0) + 1;
      notification.status = NotificationStatus.PENDING;
      await this.notificationRepository.save(notification);
      await this.processNotification(notification.id);
    }
  }
}
